spwnum = import spwnum
extract import std
extract $
extract obj_props

tensor = spwnum.tensor.tensor
vector = spwnum.vector.vector

SCALE = 2

// base verticies
bv = [-SCALE, SCALE]

// create vertices
let vertices = []

for i in bv {
    for j in bv {
        for k in bv {
            vertices.push(
                vector([i, j, k])
            )
        }
    }
}

// rotation matrices

// TRANSFORMATION = spwnum.tensor.graphics(rank = 3).rx(5) * spwnum.tensor.graphics(rank = 3).ry(5)

// rendering function
Z_OFFSET = 10
K = 160

/*
Math:
K = z', where z' is a chosen constant

(x', y') = (Kx/z, Ky/z)
*/

render_vertices = (theta: @number) {
    transform = spwnum.tensor.graphics(rank = 3).ry(theta) * spwnum.tensor.graphics(rank = 3).rx(theta)
    let ret_arr = []
    
    for i in 0..8 {
        new_v = transform * vertices[i]

        x = new_v.matrix[0][0]
        y = new_v.matrix[1][0]
        z = new_v.matrix[2][0] + Z_OFFSET

        x_p = K * x / z
        y_p = K * y / z

        ret_arr.push([x_p, y_p])
    }

    return ret_arr
}

projection_v = render_vertices(0)

// // objects
block_groups = [1g, 2g, 3g, 4g, 5g, 6g, 7g, 8g]
// FOLLOW_PLAYER_GROUP = 9g

for i in 0..8 {
    add(obj {
        OBJ_ID: 1117,
        X: projection_v[i][0],
        Y: projection_v[i][1],
        GROUPS: [block_groups[i], 9g],
    })
}

for theta in 20..20..200 {
    let v_n = render_vertices(theta * 3.14 / 180)
    let v_n_1 = render_vertices((theta - 20) * 3.14 / 180)
    
    for i in ..8 {
        let dx = v_n[i][0] - v_n_1[i][0]
        let dy = v_n[i][1] - v_n_1[i][1]
        dx /= 3
        dy /= 3

        ->block_groups[i].move(dx, dy, 2)
    }

    print("Rendered frame: " + (theta / 20) as @string + " / 9" + " at time: " + time() as @string)

    wait(2)
}