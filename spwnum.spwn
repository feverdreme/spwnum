_create_tensor = () {}

_create_tensor = (dims: @array, depth: @number = 0) {
    let ret_arr = []
    
    if depth == dims.length - 1 {
        for i in 0..dims[depth] {
            ret_arr.push(0)
        }

    } else {
        elem_arr = _create_tensor(dims, depth + 1)

        for i in 0..dims[depth] {
            ret_arr.push(elem_arr)
        }
    }

    return ret_arr
}

@array::depth = (arr: @array) {
    if arr[0].type == @number {
        return 1
    } else {
        return 1 + @array::depth(arr[0])
    }
}

@array::shape = (self) {
    // terminal case
    if self[0].type == @number {
        return [self.length]
    }

    return [self.length] + self[0].shape()
}

type @tensor
impl @tensor {
    new: (shape = null, arr = null) {
        if shape == null && arr == null {
            throw "ConstructorError: Must supply either shape or array value"
        }

        if shape != null && arr != null {
            throw "ConstructorError: Must supply only either shape or array, not both"
        }

        if shape != null {
            return {
                type: @tensor,
                matrix: _create_tensor(shape),
                shape: shape,
            }
        }

        // arr != null
        else {
            return {
                type: @tensor,
                matrix: arr,
                shape: arr.shape()
            }
        }
    },

    map: (self, func: @macro, _depth: @number = 0, _elem: @array | @number = -1) {
        elem = self.matrix if _elem == -1 else _elem

        // if mapping an array use builtin
        if self.shape.length == 1 {
            return self.matrix.map(func)
        }

        // terminal case
        if _depth == self.shape.length - 1 {
            return elem.map(func)
        }
        
        let ret_arr = []

        for e in elem {
            ret_arr.push(self.map(func, _depth + 1, e))
        }

        return ret_arr
    },

    fill: (self, val: @number) {
        return @tensor::new(arr = self.map(x => val))
    },

    neg: (self) {
        return @tensor::new(arr = self.map(x => -x))
    },

    // arithemetic
    _plus_: (self, other: @tensor) {
        return @tensor::new(arr = 
            @tensor::op_tensors((a, b) => a + b, self, other)
        )
    },
    
    _minus_: (self, other: @tensor) {
        return @tensor::new(arr =
            @tensor::op_tensors((a, b) => a - b, self, other)
        )
    }
}

@tensor::op_tensors = (op: @macro, elem1: @tensor | @array, elem2: @tensor | @array) {
    // error checking
    if elem1.type != elem2.type {
        throw "ShapeMismatch: supplied tensors have different shapes"
    }

    let iter1 = elem1
    let iter2 = elem2

    if elem1.type == @tensor {
        if elem1.shape != elem2.shape {
            throw "ShapeMismatch: supplied tensors have different shapes"
        }

        iter1 = elem1.matrix
        iter2 = elem2.matrix
    } else if elem1.type == @array {
        $.print(elem1)
        $.print(elem2)
        if elem1.shape() != elem2.shape() {
            throw "ShapeMismatch: supplied arrays have different shapes"
        }
    }

    let ret_arr = []

    // do the thing
    if iter1[0].type == @number {

        for i in 0..iter1.length {
            ret_arr.push(op(iter1[i], iter2[i]))
        }

    } else {

        for i in 0..iter1.length {
            ret_arr.push(
                @tensor::op_tensors(op, iter1[i], iter2[i])
            )
        }
    }

    return ret_arr
}

return @tensor::new